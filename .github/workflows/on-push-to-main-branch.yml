name: On Push to Main Branch

on:
  push:
    branches: [ main ]

env:
  TEST_ECR_REPO: public.ecr.aws/c9o0b7e4
  PROD_ECR_REPO: public.ecr.aws/c9o0b7e4
  ECR_USER_AGENT: aws-privateca-issuer

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Check out code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Setup Dockerx
      uses: docker/setup-buildx-action@v1
    - name: Setup AWS Credentials
      uses: aws-actions/configure-aws-credentials@master
      with:
        role-to-assume: arn:aws:iam::905418208571:role/GithubActionsPublishRole-wrichman-us-east-1
        aws-region: us-east-1
    - name: Login to Public ECR
      uses: docker/login-action@v1
      with:
        registry: public.ecr.aws
      env:
        AWS_REGION: us-east-1
    - name: Setup Push to ECR
      run: |
        export PLUGIN_VERSION=$(git describe --tags)
        export TAG_BASE=${{ env.TEST_ECR_REPO }}/$(echo ${GITHUB_REPOSITORY,,} | sed s#/#-#)-test
        echo TAG_BASE=$TAG_BASE >> $GITHUB_ENV
        echo PLUGIN_VERSION=$PLUGIN_VERSION >> $GITHUB_ENV
    - name: Build and push container images
      uses: docker/build-push-action@v6
      with:
        build-args: |
          pkg_version=${{ env.PLUGIN_VERSION }}
        context: .
        platforms: linux/amd64,linux/arm64
        tags: |
          ${{ env.TAG_BASE }}:latest
          ${{ env.TAG_BASE }}:${{ env.PLUGIN_VERSION }}
        push: true

  version-bump:
    runs-on: ubuntu-latest
    outputs:
      bump_type: ${{ steps.pr_labels.outputs.bump_type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR labels
        id: pr_labels
        uses: actions/github-script@v7
        with:
          script: |
            const commits = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha
            });

            core.info('Commit: ' + context.sha);
            core.info('Commits: ' + commits.data);
            core.setOutput('bump_type', 'none');
            if (commits.data.length > 0) {
              const labels = commits.data[0].labels.map(label => label.name);
              core.info('PR Labels:' + labels);

              const hasMinor = labels.includes('Minor Version');
              const hasPatch = labels.includes('Patch');

              if (hasMinor) {
                core.setOutput('bump_type', 'minor');
              } else if (hasPatch) {
                core.setOutput('bump_type', 'patch');
              }
            }
      - name: No version bump
        if: steps.pr_labels.outputs.bump_type == 'none'
        run: |
          echo "No version bump label found. Skipping version update."

  get-versions:
    runs-on: ubuntu-latest
    needs: version-bump
    if: ${{ needs.version-bump.outputs.bump_type != 'none' }}
    outputs:
      new_version: ${{ steps.bump_version.outputs.new_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get current version
        id: get_version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null)
          echo "Current version: $LATEST_TAG"
          echo "current_version=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Bump version
        id: bump_version
        run: |
          CURRENT="${{ steps.get_version.outputs.current_version }}"
          BUMP_TYPE="${{ needs.version-bump.outputs.bump_type }}"
          
          CURRENT=${CURRENT#v}
          
          IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT"
          MAJOR="${VERSION_PARTS[0]}"
          MINOR="${VERSION_PARTS[1]}"
          PATCH="${VERSION_PARTS[2]}"
          
          if [ "$BUMP_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [ "$BUMP_TYPE" = "patch" ]; then
            PATCH=$((PATCH + 1))
          fi
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "New version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "version_number=${MAJOR}.${MINOR}.${PATCH}" >> $GITHUB_OUTPUT

  run-for-arm:
    needs: version-bump
    if: ${{ needs.version-bump.outputs.bump_type != 'none' }}
    uses: './.github/workflows/on-safe-to-test-label.yml'
    with:
      architecture: 'arm64'

  run-for-x86:
    needs: version-bump
    if: ${{ needs.version-bump.outputs.bump_type != 'none' }}
    uses: './.github/workflows/on-safe-to-test-label.yml'
    with:
      architecture: 'x86_64'

  run-helm-tests:
    needs: version-bump
    if: ${{ needs.version-bump.outputs.bump_type != 'none' }}
    uses: './.github/workflows/helm-test.yml'

  build-public:
    name: release
    needs: [run-for-arm, run-for-x86, run-helm-tests, get-versions]
    if: ${{ needs.run-for-arm.result == 'success' && needs.run-for-x86.result == 'success' && needs.run-helm-tests.result == 'success' && needs.get-versions.result == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Setup Dockerx
        uses: docker/setup-buildx-action@v1
      - name: Setup AWS Credentials
        uses: aws-actions/configure-aws-credentials@master
        with:
          role-to-assume: arn:aws:iam::905418208571:role/GithubActionsPublishRole-wrichman-us-east-1
          aws-region: us-east-1
      - name: Login to Public ECR
        uses: docker/login-action@v1
        with:
          registry: public.ecr.aws
        env:
          AWS_REGION: us-east-1
      - name: Setup Push to Public ECR
        run: |
          export TAG_BASE=${{ env.PROD_ECR_REPO }}/$(echo ${GITHUB_REPOSITORY,,} | sed s#/#-#)
          echo TAG_BASE=$TAG_BASE >> $GITHUB_ENV
      - name: Build and push container images
        uses: docker/build-push-action@v6
        with:
          build-args: |
            pkg_version=${{ needs.get-versions.outputs.new_version }}
            user_agent=${{ env.ECR_USER_AGENT }}
          context: .
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.TAG_BASE }}:latest
            ${{ env.TAG_BASE }}:${{steps.tag.outputs.tag}}
          push: true
